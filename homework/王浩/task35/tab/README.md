### 文档说明

- 通过函数创建的构造函数对象继承的属性有俩个
    + `node`--tab的容器DOM节点
    + `data`--关于tab的所有数据
- 继承的方法有一个
    + `createNode`--用于创建tab
- 构造函数的调用如下

```javascript
var a = new Tab(node1,num1);
//node1 用于创建tab组件的父容器
//num1 用于从json中选择要呈现的tab内容
a.createNode();
//创建tab
```

- json格式说明
```json
{
    "status": 0,    //状态码
    "data": [{      //数据
        "startTag": 0,      //初始化标签
        "count": 3,         //标签按钮数量
        "imgPlay": {        //img图片hover时候icon图标位置
            "src": "img/method-draw-image.svg"
        },
        "size": {       //关于尺寸信息
            "width": 360,       //tab容器宽度
            "btnH": 36,         //tab按钮栏高度
            "padding": 10,      //tab按钮的间距
            "contH": 210,       //tab内容高度，以废弃
            "imgW": 105,        //图片的宽度
            "imgH": 70,         //图片的高度
            "imgM": 5,          //图片的间距
            "layerFPT": 10,     //tab的内容距离按钮栏的间距
            "listM": 5,         //tab的内容dev2的列表间距
            "fontS": 16         //tab字体的高度
        },
        "color": {
            "tabBg": "#fff",        //tab的背景色
            "btnBg": "#F7F7F7",     //tab的按钮栏背景色
            "border": "#DBDEE1",    //tab的border颜色
            "btnBTop": "#FF8400",   //tab按钮栏的顶部颜色条
            "fontC": "#52687e",     //字体的常规颜色
            "fontH": "#FF8400"      //字体的hover颜色
        },
        "value": [{                 //关于content的信息
            "title": "图片",          //按钮的title
            "link": "#",            //按钮的链接地址
            "content": [{           //按钮对应的内容框内容
                "cont1": [{       //内容框的第一层级，计划3层但是暂时制作了一层
                    "dev1": [{      //dev1图片的信息
                        "title": "css3",    //图片的标题
                        "src": "img/css3.svg",  //图片的位置
                        "link": "#"     //图片的链接
                    }, 
                    {...}  //重复的内容
                    ]
                }, {
                    "dev2": [{      //内容框dev2的链接内容
                        "title": "this is a title 图片",  //链接标题
                        "link": "#"     //链接地址
                    }, 
                    {...}  //重复的内容
                    ]
                }]
            }, 
            {...}]   //重复的内容
        },
        {...}   //重复的内容
    ]}
]}
```

### 项目总结：

- 想让父元素高度塌陷可以让子元素设置浮动，或者绝对定位；
- 想让父元素宽度收缩，可以设置父元素为`inline-block`,或者浮动`float`，但是俩者还是有区别的，
    + `inline-block` --宽度收缩了,但是高度会影响到外层容器，莫名其妙的多了几个像素，找不到原因.
    + `float` -- 宽度收缩，但是需要设置外层容器清除浮动，这个暂时没有发现副作用
- 当对于同一个元素同时使用`CSS`和`JS`进行样式设置时候，谁更有优先权呢，因为css一般是防止在页面的首部，而js是防止在底部，所以先加载的css会被后加载的js覆盖，如果俩个效果都像保留，那么就尝试把js的样式控制放置到子元素身上实现相同效果，然后通过css控制元素，这样就是个好的办法。
- 事件代理对于鼠标点击事件有效，可以通过`e.target`找到点击的子元素信息，但是对于`mouseenter`和`mouseleave`就不行，通过`e.target`只会输出父元素的信息，无法识别鼠标`hover`的是哪个子元素。
- 防止tab按钮hover时候跳动，可以先添加一个背景色的边框，hover时候改变边框颜色；
<!-- - `tab`按钮和内容分开好还是融合在一起好，就效果来说都可以实现，可以根据标签值来响应，但是就`DOM`语义化来说，我觉得融合在一起好，因为本来就是相关性内容；
 -->
 - 其实融合到一起我暂时无法实现，因为进行绝对定位的时候内容框左边无法对齐，所以还是单独分割开，
 - 对于`a`链接的内部如果有图片的话，`a`链接的高度就会多出`4px`，这是因为图片是行内元素，对齐方式不是按照底部对齐的，所以需要给`img`设置对齐方式为底部对齐，`vertical-align: bottom`，这样就好了。
 - 对于样式的控制使用css好还是使用js好，看用途了，如果是封装一个组件，通过构造函数来调用的时候，为了实现各个组件的差异化，这时候就最好使用js通过json调取颜色或者尺寸信息，因为这样可以实现每个组件的差异化，而如果是使用css控制的样式，那么每个组件的样式都是一样的，没办法时候差异化，或者是重新写样式覆盖默认的样式，但总觉的不好。
 - 当然了，js和css协作是很好的，因为css可以减少js的很多样式控制代码，而且查看css会比js方便。这个还是看使用场景了。

> 很小的一个组件，可是我写起来用了350行左右的代码，这个仅次于那个轮播组件了，但是轮播组件更多的是js的逻辑考虑，而这个难度明显没有那个高，但是对于css的考虑会很多，其实这样时间算下来也差不太多，对于这个组件的封装性暂时还是比较满意的。
> 期待以后进一步优化吧……
